{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Applauncher Applauncher is a tool that helps you to reuse your code by sharing all default functionalities among all of your projects. When you have several projects you realize that, in the beginning, you always write the same stuff (the database connection handlers, the configuration loader...). And it is very annoying. More than annoying, it is a problem because everytime you create a new project you need to spend time and the components are not exactly the same (due little customizations). In summary, if I usually use mongodb and redis , why not just create a thing that just provides me that? It's like using libraries , but in this case we import features . This tool was developed with the following ideas in mind: Not intrusive: It does not tell you how to develop, but you should adapt your main.py (in the end applauncher is a launcher) Simple: Your applications are complex enough to add even more Fast: Applauncher should not steal your computing resources Tested: Applauncher is tested and relies on very tested libraries Community: Since many requirements are common (mysql, sentry...) any contribution can be enjoyed by anyone! Bundleszzzzzz","title":"Applauncher"},{"location":"index.html#applauncher","text":"Applauncher is a tool that helps you to reuse your code by sharing all default functionalities among all of your projects. When you have several projects you realize that, in the beginning, you always write the same stuff (the database connection handlers, the configuration loader...). And it is very annoying. More than annoying, it is a problem because everytime you create a new project you need to spend time and the components are not exactly the same (due little customizations). In summary, if I usually use mongodb and redis , why not just create a thing that just provides me that? It's like using libraries , but in this case we import features . This tool was developed with the following ideas in mind: Not intrusive: It does not tell you how to develop, but you should adapt your main.py (in the end applauncher is a launcher) Simple: Your applications are complex enough to add even more Fast: Applauncher should not steal your computing resources Tested: Applauncher is tested and relies on very tested libraries Community: Since many requirements are common (mysql, sentry...) any contribution can be enjoyed by anyone! Bundleszzzzzz","title":"Applauncher"},{"location":"anatomy.html","text":"Anatomy Applauncher tends to be as more simple as possible. These are the main elements that you need to Know Bundle A bundle is like a feature that Applaucher will offer to your application. For example, a functionality to get a mongodb working in your application will contain the configuration information, the way to create a mongo connection and how to provide this connection (usually by dependency injection). So you just import this bundle and from your code you just request a mongo connection. You dont have to handle the initialization, configuration, closing connections... You just write your code and inject all your dependencies. A bundle looks something like this: from applauncher import Kernel, event from pydantic import BaseModel from dependency_injector import providers class MysqlClient: def __init__(self, port: int, hostname: str, database: str): # This is a fake mysql cliente, but in should # be an sqlalchmy connection or something like this pass def execute_query(self, query: str, params): pass class MysqlConfig(BaseModel): port: int = 3306 hostname: str database: str class MysqlBundle: def __init__(self): # At this moment we are defining something like a bundle manifest # The configuration required for this bundle self.config_mapping = { \"mysql\": MysqlConfig } # Subscribe to some events self.event_listeners = [ (event.ConfigurationReadyEvent, self.configuration_ready) ] def configuration_ready(self, event): config = event.configuration.mysql # In config we have the model `MysqlConfig` but populated # Here we define the dependency injection. We basically tell # what classes will be available to be injected and # the parameters needed by the container to instantiate it. # This example is using the factory injection (a new # instance will created on every injection) but there are # more options like singleton (when you want to share # the same instance) and more posibilites. self.injection_bindings = { MysqlClient: providers.Factory( MysqlClient, port=config.port, hostname=config.hostname, database=config.database ) } # In this example, a service does not make sense but it # should only `provide` a mysql connection. But since # this is an example, we will configure one. # [45] is the args and {} the kwargs provided to your # service function self.services = [ (\"my_service\", self.service, [45], {\"foo\": \"bar\"}) ] # This function will be executed in a separate process once # the kernel is ready (configuration loaded, dependency # container created...) def service(self, value, foo): from time import sleep while True: print(\"Value is\", 45, foo) # Value is 45 bar sleep(1) # Create the kernel providing the bundles (here only one, # but in a real application you use several bundles). # The line `kernel.wait()` will wait until all `services` # finishes and in case a signal (ctrl + c or kill) is # received, it will try to finish all services gracefully. with Kernel(bundles=[MysqlBundle()], environment=\"PROD\") as kernel: kernel.wait() Service It is your code. It can be a web application, your program that processes files, a threaded application... whatever you want. Configuration mapping If your bundle requires configuration, you have to provide to the application this fields. This mapping contains for example the connection uri to your database. Applauncher will validate all these information and provides it to the bundle so we can trust this information. The information can comes from a config file, environment variables... Your code does not really care, if just wants the values. The validation process relies on Pydantic so your validations will be very fast and powerful. Events Applauncher is event driven. You can raise events (information that is useful to other bundles) and subscribe to events (in case you want to get notified about something). For example, kafka_bundle will raise events on every message received so your application (and any other bundle) will subscribe to this event. Dependency injection This is the mechanism used to provide and ask for services. Your bundle provide things (like a database connection) to be injected and other bundles (like your application) can inject them. The dependency injection feature relies on Dependency Injector , check its documentation to see all amazing features. Kernel The kernel is just the thing that prepares the environment. Basically it loads the configuration and initialize the bundles and the very basic features (like the dependency injector container or the event system). The kernel also send events to notify these steps (when the configuarion is ready, when the application is fully loaded or when the bundles should shutdown because a sigterm was received). But there is nothing smart in this kernel, it will not take the control of your application or any unexpected thing at all. The hearth will always be your application.","title":"Anatomy"},{"location":"anatomy.html#anatomy","text":"Applauncher tends to be as more simple as possible. These are the main elements that you need to Know","title":"Anatomy"},{"location":"anatomy.html#bundle","text":"A bundle is like a feature that Applaucher will offer to your application. For example, a functionality to get a mongodb working in your application will contain the configuration information, the way to create a mongo connection and how to provide this connection (usually by dependency injection). So you just import this bundle and from your code you just request a mongo connection. You dont have to handle the initialization, configuration, closing connections... You just write your code and inject all your dependencies. A bundle looks something like this: from applauncher import Kernel, event from pydantic import BaseModel from dependency_injector import providers class MysqlClient: def __init__(self, port: int, hostname: str, database: str): # This is a fake mysql cliente, but in should # be an sqlalchmy connection or something like this pass def execute_query(self, query: str, params): pass class MysqlConfig(BaseModel): port: int = 3306 hostname: str database: str class MysqlBundle: def __init__(self): # At this moment we are defining something like a bundle manifest # The configuration required for this bundle self.config_mapping = { \"mysql\": MysqlConfig } # Subscribe to some events self.event_listeners = [ (event.ConfigurationReadyEvent, self.configuration_ready) ] def configuration_ready(self, event): config = event.configuration.mysql # In config we have the model `MysqlConfig` but populated # Here we define the dependency injection. We basically tell # what classes will be available to be injected and # the parameters needed by the container to instantiate it. # This example is using the factory injection (a new # instance will created on every injection) but there are # more options like singleton (when you want to share # the same instance) and more posibilites. self.injection_bindings = { MysqlClient: providers.Factory( MysqlClient, port=config.port, hostname=config.hostname, database=config.database ) } # In this example, a service does not make sense but it # should only `provide` a mysql connection. But since # this is an example, we will configure one. # [45] is the args and {} the kwargs provided to your # service function self.services = [ (\"my_service\", self.service, [45], {\"foo\": \"bar\"}) ] # This function will be executed in a separate process once # the kernel is ready (configuration loaded, dependency # container created...) def service(self, value, foo): from time import sleep while True: print(\"Value is\", 45, foo) # Value is 45 bar sleep(1) # Create the kernel providing the bundles (here only one, # but in a real application you use several bundles). # The line `kernel.wait()` will wait until all `services` # finishes and in case a signal (ctrl + c or kill) is # received, it will try to finish all services gracefully. with Kernel(bundles=[MysqlBundle()], environment=\"PROD\") as kernel: kernel.wait()","title":"Bundle"},{"location":"anatomy.html#service","text":"It is your code. It can be a web application, your program that processes files, a threaded application... whatever you want.","title":"Service"},{"location":"anatomy.html#configuration-mapping","text":"If your bundle requires configuration, you have to provide to the application this fields. This mapping contains for example the connection uri to your database. Applauncher will validate all these information and provides it to the bundle so we can trust this information. The information can comes from a config file, environment variables... Your code does not really care, if just wants the values. The validation process relies on Pydantic so your validations will be very fast and powerful.","title":"Configuration mapping"},{"location":"anatomy.html#events","text":"Applauncher is event driven. You can raise events (information that is useful to other bundles) and subscribe to events (in case you want to get notified about something). For example, kafka_bundle will raise events on every message received so your application (and any other bundle) will subscribe to this event.","title":"Events"},{"location":"anatomy.html#dependency-injection","text":"This is the mechanism used to provide and ask for services. Your bundle provide things (like a database connection) to be injected and other bundles (like your application) can inject them. The dependency injection feature relies on Dependency Injector , check its documentation to see all amazing features.","title":"Dependency injection"},{"location":"anatomy.html#kernel","text":"The kernel is just the thing that prepares the environment. Basically it loads the configuration and initialize the bundles and the very basic features (like the dependency injector container or the event system). The kernel also send events to notify these steps (when the configuarion is ready, when the application is fully loaded or when the bundles should shutdown because a sigterm was received). But there is nothing smart in this kernel, it will not take the control of your application or any unexpected thing at all. The hearth will always be your application.","title":"Kernel"},{"location":"getting_started.html","text":"Getting started Applauncher tends to be as more simple as possible. These are the main elements that you need to Know Bundle A bundle is like a functionality that Applaucher will offer to your application. For example, a functionality to get a mongodb working in your application will contain the configuration information, the way to create a mongo connection and how to provide this connection (usually by dependency injection). So you just import this bundle and from your code you just request a mongo connection. You dont have to handle the initialization, configuration, closing connections... You just write your code and inject all your dependencies. Service It is your code. It can be a web application, your program that processes files, a threaded application... whatever you want. Configuaration mapping Events","title":"Getting started"},{"location":"getting_started.html#getting-started","text":"Applauncher tends to be as more simple as possible. These are the main elements that you need to Know","title":"Getting started"},{"location":"getting_started.html#bundle","text":"A bundle is like a functionality that Applaucher will offer to your application. For example, a functionality to get a mongodb working in your application will contain the configuration information, the way to create a mongo connection and how to provide this connection (usually by dependency injection). So you just import this bundle and from your code you just request a mongo connection. You dont have to handle the initialization, configuration, closing connections... You just write your code and inject all your dependencies.","title":"Bundle"},{"location":"getting_started.html#service","text":"It is your code. It can be a web application, your program that processes files, a threaded application... whatever you want.","title":"Service"},{"location":"getting_started.html#configuaration-mapping","text":"","title":"Configuaration mapping"},{"location":"getting_started.html#events","text":"","title":"Events"},{"location":"kernel_lifecycle.html","text":"Kernel lifecycle There is a little lifecycle process since you run python until the application finishes, in order the events are: * ConfigurationReady * InjectorReady * KernelReady * KernelShutdown Your main application will run after the event KernelReady ConfigurationReadyEvent This event will provide you the configuration parsed and validated. In case of any error, the information will be displayed specifying in a friendly way the errors to fix. Used when a bundle needs this to provide some service to inject , like a database connection. InjectorReady At this point everything is ready but until the application code can run, this event allows to do a last thing. This is useful when a bundle needs another bundle. It's not very common because dependency injection solves most of the cases but you sometimes you need it. We can think this event like a pre run . KernelReady At this point the application is fully started. Is when the services are started and here is when your code will start running. Here you can inject or do whatever you want KernelShutdown When a ctrl + c or sigterm is received, the kernel will raise this event. The bundles subscribed to this event should prepare the shutdown process (close connection), and your service will receive the signal to start the shutdown process. By default, there will be grace time of 10 seconds. If any code is not able to be stopped in this grace time period, it will be killed. Anyway, resending the sigterm signal will kill the processes too.","title":"Kernel lifecycle"},{"location":"kernel_lifecycle.html#kernel-lifecycle","text":"There is a little lifecycle process since you run python until the application finishes, in order the events are: * ConfigurationReady * InjectorReady * KernelReady * KernelShutdown Your main application will run after the event KernelReady","title":"Kernel lifecycle"},{"location":"kernel_lifecycle.html#configurationreadyevent","text":"This event will provide you the configuration parsed and validated. In case of any error, the information will be displayed specifying in a friendly way the errors to fix. Used when a bundle needs this to provide some service to inject , like a database connection.","title":"ConfigurationReadyEvent"},{"location":"kernel_lifecycle.html#injectorready","text":"At this point everything is ready but until the application code can run, this event allows to do a last thing. This is useful when a bundle needs another bundle. It's not very common because dependency injection solves most of the cases but you sometimes you need it. We can think this event like a pre run .","title":"InjectorReady"},{"location":"kernel_lifecycle.html#kernelready","text":"At this point the application is fully started. Is when the services are started and here is when your code will start running. Here you can inject or do whatever you want","title":"KernelReady"},{"location":"kernel_lifecycle.html#kernelshutdown","text":"When a ctrl + c or sigterm is received, the kernel will raise this event. The bundles subscribed to this event should prepare the shutdown process (close connection), and your service will receive the signal to start the shutdown process. By default, there will be grace time of 10 seconds. If any code is not able to be stopped in this grace time period, it will be killed. Anyway, resending the sigterm signal will kill the processes too.","title":"KernelShutdown"}]}